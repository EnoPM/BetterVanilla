using System.Text;
using BetterVanilla.Ui.XamlGenerator.Models;

namespace BetterVanilla.Ui.XamlGenerator;

/// <summary>
/// Generates C# code from parsed ViewDefinition.
/// </summary>
public sealed class CodeGenerator
{
    private readonly AliasConfig _aliasConfig;
    private readonly StringBuilder _sb = new();
    private int _indent;
    private int _anonymousCounter;

    public CodeGenerator(AliasConfig aliasConfig)
    {
        _aliasConfig = aliasConfig;
    }

    public string Generate(ViewDefinition definition)
    {
        _sb.Clear();
        _indent = 0;
        _anonymousCounter = 0;

        // Header
        AppendLine("// <auto-generated/>");
        AppendLine("// This file was generated by BetterVanilla.Ui.XamlGenerator.");
        AppendLine("// Do not modify this file manually.");
        AppendLine();
        AppendLine("#nullable enable");
        AppendLine();

        // Usings
        AppendLine("using System;");
        AppendLine("using System.Collections.Generic;");
        AppendLine("using BetterVanilla.Ui.Binding;");
        AppendLine("using BetterVanilla.Ui.Controls;");
        AppendLine("using BetterVanilla.Ui.Core;");
        AppendLine("using BetterVanilla.Ui.Helpers;");
        AppendLine("using UnityEngine;");
        AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(definition.Namespace))
        {
            AppendLine($"namespace {definition.Namespace};");
            AppendLine();
        }

        // Class (no base class - user code specifies it)
        AppendLine($"public partial class {definition.TypeName}");
        AppendLine("{");
        _indent++;

        GenerateFields(definition);
        AppendLine();
        GenerateAliasMap(definition);
        AppendLine();
        GenerateInitializeComponent(definition);
        AppendLine();
        GenerateSetupBindings(definition);
        AppendLine();
        GenerateSetupEventHandlers(definition);
        AppendLine();
        GeneratePartialMethods(definition);

        _indent--;
        AppendLine("}");

        return _sb.ToString();
    }

    private void GenerateFields(ViewDefinition definition)
    {
        AppendLine("#region View Elements");
        AppendLine();

        foreach (var element in definition.NamedElements)
        {
            var componentType = ResolveComponentType(element);
            AppendLine($"[ViewElement(\"{element.Name}\")]");
            AppendLine($"public {componentType} {element.Name} {{ get; private set; }} = null!;");
            AppendLine();
        }

        AppendLine("#endregion");
    }

    private void GenerateAliasMap(ViewDefinition definition)
    {
        AppendLine("#region Alias Mappings");
        AppendLine();
        AppendLine("private static readonly Dictionary<string, (string Bundle, string Prefab, Type Component)> AliasMap = new()");
        AppendLine("{");
        _indent++;

        var processedAliases = new HashSet<string>();

        foreach (var element in definition.NamedElements)
        {
            var alias = element.Alias ?? element.TagName;
            if (processedAliases.Contains(alias))
                continue;

            processedAliases.Add(alias);

            if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
            {
                var bundle = aliasDef.Bundle ?? _aliasConfig.DefaultBundle ?? "ui.bundle";
                AppendLine($"[\"{alias}\"] = (\"{bundle}\", \"{aliasDef.Prefab}\", typeof({aliasDef.Component})),");
            }
        }

        _indent--;
        AppendLine("};");
        AppendLine();
        AppendLine("#endregion");
    }

    private void GenerateInitializeComponent(ViewDefinition definition)
    {
        AppendLine("protected override void InitializeComponent()");
        AppendLine("{");
        _indent++;

        AppendLine("// Load and instantiate elements");

        if (definition.RootElement != null)
        {
            GenerateElementInstantiation(definition.RootElement, "transform", isRoot: true);
        }

        AppendLine();
        AppendLine("// Register elements");
        foreach (var element in definition.NamedElements)
        {
            AppendLine($"RegisterElement(\"{element.Name}\", {element.Name});");
        }

        AppendLine();
        AppendLine("base.InitializeComponent();");

        _indent--;
        AppendLine("}");
    }

    private void GenerateElementInstantiation(ViewElement element, string parentVar, bool isRoot = false)
    {
        // If this is the root element (View/Window/etc.), skip instantiation and just process children
        // The root element represents the view itself, not a child control
        if (isRoot && string.IsNullOrEmpty(element.Name))
        {
            foreach (var child in element.Children)
            {
                GenerateElementInstantiation(child, parentVar);
            }
            return;
        }

        var alias = element.Alias ?? element.TagName;
        var componentType = ResolveComponentType(element);

        // Determine variable name - use element name or generate anonymous name
        var isAnonymous = string.IsNullOrEmpty(element.Name);
        var varName = isAnonymous
            ? $"_anonymous{element.TagName}{_anonymousCounter++}"
            : element.Name!;

        AppendLine();
        if (isAnonymous)
        {
            AppendLine($"// Instantiate anonymous {element.TagName}");
        }
        else
        {
            AppendLine($"// Instantiate {element.Name}");
        }

        if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
        {
            var bundle = aliasDef.Bundle ?? _aliasConfig.DefaultBundle ?? "ui.bundle";
            if (isAnonymous)
            {
                AppendLine($"var {varName} = InstantiateControl<{componentType}>(\"{bundle}\", \"{aliasDef.Prefab}\", {parentVar});");
            }
            else
            {
                AppendLine($"{element.Name} = InstantiateControl<{componentType}>(\"{bundle}\", \"{aliasDef.Prefab}\", {parentVar});");
            }
        }
        else
        {
            // Fallback - create empty GameObject with component
            AppendLine($"var {varName}Go = new GameObject(\"{varName}\");");
            AppendLine($"{varName}Go.transform.SetParent({parentVar}, false);");
            if (isAnonymous)
            {
                AppendLine($"var {varName} = {varName}Go.AddComponent<{componentType}>();");
            }
            else
            {
                AppendLine($"{element.Name} = {varName}Go.AddComponent<{componentType}>();");
            }
        }

        AppendLine($"{varName}.Name = \"{varName}\";");
        AppendLine($"{varName}.Initialize();");

        // Set literal properties
        foreach (var (propName, propValue) in element.LiteralProperties)
        {
            var formattedValue = FormatPropertyValue(propName, propValue);
            AppendLine($"{varName}.{propName} = {formattedValue};");
        }

        // Set layout properties
        GenerateLayoutCode(element, varName);

        // Set text style if present (for controls with labels)
        if (element.TextStyle is { HasAnyValue: true })
        {
            GenerateTextStyleCode(element.TextStyle, varName, "Label");
        }

        // Set placeholder style if present (for InputField)
        if (element.PlaceholderStyle is { HasAnyValue: true })
        {
            GenerateTextStyleCode(element.PlaceholderStyle, varName, "Placeholder");
        }

        // Wire up event handlers inline (for both named and anonymous elements)
        GenerateInlineEventHandlers(element, varName, componentType);

        // Process children
        // ScrollView children should be added to ContentTransform, not transform
        var childParent = element.TagName == "ScrollView"
            ? $"{varName}.ContentTransform"
            : $"{varName}.transform";
        foreach (var child in element.Children)
        {
            GenerateElementInstantiation(child, childParent);
        }
    }

    /// <summary>
    /// Generates inline event handler wiring for an element.
    /// Only generates for anonymous elements - named elements are handled in SetupEventHandlers.
    /// </summary>
    private void GenerateInlineEventHandlers(ViewElement element, string varName, string componentType)
    {
        // Skip named elements - their events are wired in SetupEventHandlers()
        if (!string.IsNullOrEmpty(element.Name))
            return;

        foreach (var (eventName, handlerName) in element.EventHandlers)
        {
            switch (eventName)
            {
                case "Click" or "Clicked":
                    AppendLine($"if ({varName} is IClickableControl clickable{varName})");
                    AppendLine("{");
                    _indent++;
                    AppendLine($"clickable{varName}.Clicked += {handlerName};");
                    _indent--;
                    AppendLine("}");
                    break;

                case "ValueChanged":
                    var valueType = GetValueTypeForComponent(componentType);
                    if (valueType != null)
                    {
                        AppendLine($"{varName}.ValueChanged += value => {handlerName}(value);");
                    }
                    break;

                case "SelectedIndexChanged":
                    if (componentType == "DropdownControl")
                    {
                        AppendLine($"{varName}.SelectedIndexChanged += value => {handlerName}(value);");
                    }
                    break;
            }
        }
    }

    /// <summary>
    /// Generates code for a dimension property (Width, Height, etc.) that supports both fixed values and percentages.
    /// </summary>
    private void GenerateDimensionCode(string varName, string propertyName, string? value)
    {
        if (string.IsNullOrEmpty(value))
            return;

        var (parsedValue, isPercentage) = LayoutInfo.ParseDimension(value);

        if (isPercentage)
        {
            // Use percentage setter: SetWidthPercent(50) for "50%"
            AppendLine($"{varName}.Set{propertyName}Percent({parsedValue}f);");
        }
        else
        {
            // Use fixed value
            AppendLine($"{varName}.{propertyName} = {parsedValue}f;");
        }
    }

    private void GenerateTextStyleCode(TextStyleInfo style, string varName, string prefix)
    {
        if (style.FontSize.HasValue)
            AppendLine($"{varName}.{prefix}FontSize = {style.FontSize.Value}f;");

        if (!string.IsNullOrEmpty(style.TextColor))
            AppendLine($"{varName}.{prefix}TextColor = PanelControl.ParseColor(\"{style.TextColor}\");");

        if (!string.IsNullOrEmpty(style.TextAlignment))
            AppendLine($"{varName}.{prefix}TextAlignment = TMPro.TextAlignmentOptions.{style.TextAlignment};");

        if (!string.IsNullOrEmpty(style.FontStyle))
            AppendLine($"{varName}.{prefix}FontStyle = TMPro.FontStyles.{style.FontStyle};");

        if (style.CharacterSpacing.HasValue)
            AppendLine($"{varName}.{prefix}CharacterSpacing = {style.CharacterSpacing.Value}f;");

        if (style.LineSpacing.HasValue)
            AppendLine($"{varName}.{prefix}LineSpacing = {style.LineSpacing.Value}f;");

        if (style.WordSpacing.HasValue)
            AppendLine($"{varName}.{prefix}WordSpacing = {style.WordSpacing.Value}f;");

        if (style.WordWrapping.HasValue)
            AppendLine($"{varName}.{prefix}WordWrapping = {style.WordWrapping.Value.ToString().ToLowerInvariant()};");

        if (!string.IsNullOrEmpty(style.TextOverflow))
            AppendLine($"{varName}.{prefix}TextOverflow = TMPro.TextOverflowModes.{style.TextOverflow};");

        if (style.RichText.HasValue)
            AppendLine($"{varName}.{prefix}RichText = {style.RichText.Value.ToString().ToLowerInvariant()};");

        if (style.AutoSize.HasValue)
            AppendLine($"{varName}.{prefix}AutoSize = {style.AutoSize.Value.ToString().ToLowerInvariant()};");

        if (style.MinFontSize.HasValue)
            AppendLine($"{varName}.{prefix}MinFontSize = {style.MinFontSize.Value}f;");

        if (style.MaxFontSize.HasValue)
            AppendLine($"{varName}.{prefix}MaxFontSize = {style.MaxFontSize.Value}f;");

        if (!string.IsNullOrEmpty(style.TextMargin))
            AppendLine($"{varName}.{prefix}TextMargin = LabelStyleHelper.ParseMargin(\"{style.TextMargin}\");");
    }

    private void GenerateLayoutCode(ViewElement element, string varName)
    {
        var layout = element.Layout;
        var layoutGroup = element.LayoutGroup;
        var image = element.Image;
        var hasLayout = layout.HasAnyValue;
        var hasLayoutGroup = layoutGroup?.HasAnyValue == true;
        var hasImage = image?.HasAnyValue == true;

        if (!hasLayout && !hasLayoutGroup && !hasImage)
            return;

        // Panel and ScrollView properties
        var isPanel = element.TagName == "Panel";
        var isScrollView = element.TagName == "ScrollView";
        var isIconButton = element.TagName == "IconButton";
        var isLayoutContainer = isPanel || isScrollView;
        var supportsImage = isPanel || isScrollView || isIconButton;

        // LayoutGroup properties (from Panel.LayoutGroup or ScrollView.LayoutGroup element)
        if (isLayoutContainer && hasLayoutGroup)
        {
            // Orientation must be set first to create the LayoutGroup component
            if (!string.IsNullOrEmpty(layoutGroup!.Orientation))
                AppendLine($"{varName}.Orientation = Orientation.{layoutGroup.Orientation};");

            if (!string.IsNullOrEmpty(layoutGroup.Padding))
                AppendLine($"{varName}.Padding = Thickness.Parse(\"{layoutGroup.Padding}\");");

            if (layoutGroup.Spacing.HasValue)
                AppendLine($"{varName}.Spacing = {layoutGroup.Spacing.Value}f;");

            if (!string.IsNullOrEmpty(layoutGroup.ChildAlignment))
                AppendLine($"{varName}.ChildAlignment = ChildAlignment.{layoutGroup.ChildAlignment};");

            if (layoutGroup.ChildControlWidth.HasValue)
                AppendLine($"{varName}.ChildControlWidth = {layoutGroup.ChildControlWidth.Value.ToString().ToLowerInvariant()};");

            if (layoutGroup.ChildControlHeight.HasValue)
                AppendLine($"{varName}.ChildControlHeight = {layoutGroup.ChildControlHeight.Value.ToString().ToLowerInvariant()};");

            if (layoutGroup.ChildForceExpandWidth.HasValue)
                AppendLine($"{varName}.ChildForceExpandWidth = {layoutGroup.ChildForceExpandWidth.Value.ToString().ToLowerInvariant()};");

            if (layoutGroup.ChildForceExpandHeight.HasValue)
                AppendLine($"{varName}.ChildForceExpandHeight = {layoutGroup.ChildForceExpandHeight.Value.ToString().ToLowerInvariant()};");

            if (layoutGroup.ReverseArrangement.HasValue)
                AppendLine($"{varName}.ReverseArrangement = {layoutGroup.ReverseArrangement.Value.ToString().ToLowerInvariant()};");
        }

        // Image properties (from Panel.Image, ScrollView.Image, or IconButton.Image element)
        if (supportsImage && hasImage)
        {
            if (isIconButton)
            {
                // IconButton has Source, Color, PreserveAspect, ImageType, and sprite loading options
                if (!string.IsNullOrEmpty(image!.Source))
                    AppendLine($"{varName}.Source = \"{EscapeString(image.Source)}\";");

                if (!string.IsNullOrEmpty(image.Color))
                    AppendLine($"{varName}.Color = PanelControl.ParseColor(\"{image.Color}\");");

                if (image.PreserveAspect.HasValue)
                    AppendLine($"{varName}.PreserveAspect = {image.PreserveAspect.Value.ToString().ToLowerInvariant()};");

                if (!string.IsNullOrEmpty(image.ImageType))
                    AppendLine($"{varName}.ImageType = UnityEngine.UI.Image.Type.{image.ImageType};");

                // Sprite loading options
                if (image.PixelsPerUnit.HasValue)
                    AppendLine($"{varName}.PixelsPerUnit = {image.PixelsPerUnit.Value}f;");

                if (!string.IsNullOrEmpty(image.Pivot))
                    AppendLine($"{varName}.Pivot = ImageLoadingHelper.ParsePivot(\"{image.Pivot}\");");

                if (!string.IsNullOrEmpty(image.WrapMode))
                    AppendLine($"{varName}.WrapMode = TextureWrapMode.{image.WrapMode};");

                if (!string.IsNullOrEmpty(image.FilterMode))
                    AppendLine($"{varName}.FilterMode = FilterMode.{image.FilterMode};");
            }
            else
            {
                // Panel and ScrollView use Background for color
                if (!string.IsNullOrEmpty(image!.Color))
                    AppendLine($"{varName}.Background = PanelControl.ParseColor(\"{image.Color}\");");

                // Note: Source, PreserveAspect, ImageType not yet supported on Panel/ScrollView
            }
        }

        // Width/Height support both fixed values and percentages
        GenerateDimensionCode(varName, "Width", layout.Width);
        GenerateDimensionCode(varName, "Height", layout.Height);
        GenerateDimensionCode(varName, "MinWidth", layout.MinWidth);
        GenerateDimensionCode(varName, "MinHeight", layout.MinHeight);
        GenerateDimensionCode(varName, "MaxWidth", layout.MaxWidth);
        GenerateDimensionCode(varName, "MaxHeight", layout.MaxHeight);

        if (layout.FlexibleWidth.HasValue)
            AppendLine($"{varName}.FlexibleWidth = {layout.FlexibleWidth.Value}f;");

        if (layout.FlexibleHeight.HasValue)
            AppendLine($"{varName}.FlexibleHeight = {layout.FlexibleHeight.Value}f;");

        if (!string.IsNullOrEmpty(layout.Margin))
            AppendLine($"{varName}.Margin = Thickness.Parse(\"{layout.Margin}\");");

        if (!string.IsNullOrEmpty(layout.HorizontalAlignment))
            AppendLine($"{varName}.HorizontalAlignment = HorizontalAlignment.{layout.HorizontalAlignment};");

        if (!string.IsNullOrEmpty(layout.VerticalAlignment))
            AppendLine($"{varName}.VerticalAlignment = VerticalAlignment.{layout.VerticalAlignment};");

        // Call ApplyLayout at the end to apply all changes
        AppendLine($"{varName}.ApplyLayout();");
    }

    private void GenerateSetupBindings(ViewDefinition definition)
    {
        AppendLine("protected override void SetupBindings()");
        AppendLine("{");
        _indent++;

        var hasBindings = false;

        foreach (var element in definition.NamedElements)
        {
            foreach (var (propName, binding) in element.Bindings)
            {
                hasBindings = true;
                AppendLine($"Bind(\"{binding.Path}\", {element.Name}, \"{propName}\", BindingMode.{binding.Mode}).AddTo(Disposables);");
            }
        }

        if (!hasBindings)
        {
            AppendLine("// No bindings defined");
        }

        _indent--;
        AppendLine("}");
    }

    private void GenerateSetupEventHandlers(ViewDefinition definition)
    {
        AppendLine("protected override void SetupEventHandlers()");
        AppendLine("{");
        _indent++;

        var hasEvents = false;

        foreach (var element in definition.NamedElements)
        {
            foreach (var (eventName, handlerName) in element.EventHandlers)
            {
                hasEvents = true;
                var componentType = ResolveComponentType(element);
                var valueType = GetValueTypeForComponent(componentType);

                // Handle common events
                switch (eventName)
                {
                    case "Click" or "Clicked":
                        AppendLine($"if ({element.Name} is IClickableControl clickable{element.Name})");
                        AppendLine("{");
                        _indent++;
                        AppendLine($"clickable{element.Name}.Clicked += {handlerName};");
                        _indent--;
                        AppendLine("}");
                        break;

                    case "ValueChanged":
                        if (valueType != null)
                        {
                            // We know the specific value type for this control
                            AppendLine($"{element.Name}.ValueChanged += value => {handlerName}(value);");
                        }
                        else
                        {
                            // Unknown control type - use dynamic check (but this should be rare)
                            AppendLine($"// Unknown control type: {componentType}");
                        }
                        break;

                    case "SelectedIndexChanged":
                        // DropdownControl-specific event (alias for ValueChanged)
                        if (componentType == "DropdownControl")
                        {
                            AppendLine($"{element.Name}.SelectedIndexChanged += value => {handlerName}(value);");
                        }
                        else
                        {
                            AppendLine($"// TODO: Wire up {eventName} to {handlerName}");
                        }
                        break;

                    default:
                        AppendLine($"// TODO: Wire up {eventName} to {handlerName}");
                        break;
                }
            }
        }

        if (!hasEvents)
        {
            AppendLine("// No event handlers defined");
        }

        _indent--;
        AppendLine("}");
    }

    /// <summary>
    /// Gets the value type for a known control component type.
    /// </summary>
    private static string? GetValueTypeForComponent(string componentType)
    {
        return componentType switch
        {
            "ToggleControl" => "bool",
            "SliderControl" => "float",
            "InputFieldControl" => "string",
            "DropdownControl" => "int",
            _ => null
        };
    }

    /// <summary>
    /// Recursively collects event handlers from all elements in the tree.
    /// </summary>
    private void CollectEventHandlers(ViewElement element, Dictionary<string, HashSet<string?>> methodSignatures)
    {
        var componentType = ResolveComponentType(element);

        foreach (var (eventName, handlerName) in element.EventHandlers)
        {
            if (!methodSignatures.TryGetValue(handlerName, out var paramTypes))
            {
                paramTypes = new HashSet<string?>();
                methodSignatures[handlerName] = paramTypes;
            }

            if (eventName is "Click" or "Clicked")
            {
                paramTypes.Add(null); // No parameter
            }
            else if (eventName == "ValueChanged")
            {
                var valueType = GetValueTypeForComponent(componentType);
                if (valueType != null)
                {
                    paramTypes.Add(valueType);
                }
            }
            else if (eventName == "SelectedIndexChanged")
            {
                if (componentType == "DropdownControl")
                {
                    paramTypes.Add("int");
                }
            }
        }

        // Recurse into children
        foreach (var child in element.Children)
        {
            CollectEventHandlers(child, methodSignatures);
        }
    }

    private void GeneratePartialMethods(ViewDefinition definition)
    {
        AppendLine("#region Partial Methods (implement in user code)");
        AppendLine();

        // Collect methods with their expected parameter types from ALL elements (including anonymous)
        var methodSignatures = new Dictionary<string, HashSet<string?>>();

        if (definition.RootElement != null)
        {
            CollectEventHandlers(definition.RootElement, methodSignatures);
        }

        foreach (var (method, paramTypes) in methodSignatures)
        {
            foreach (var paramType in paramTypes)
            {
                if (paramType == null)
                {
                    AppendLine($"partial void {method}();");
                }
                else
                {
                    AppendLine($"partial void {method}({paramType} value);");
                }
            }
        }

        AppendLine();
        AppendLine("#endregion");
    }

    private string ResolveComponentType(ViewElement element)
    {
        var alias = element.Alias ?? element.TagName;

        if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
        {
            // Return just the type name, not the full namespace
            var lastDot = aliasDef.Component.LastIndexOf('.');
            return lastDot > 0 ? aliasDef.Component[(lastDot + 1)..] : aliasDef.Component;
        }

        // Default to tag name + Control suffix
        return element.TagName.EndsWith("Control") ? element.TagName : $"{element.TagName}Control";
    }

    // Known enum properties and their C# type names
    private static readonly Dictionary<string, string> EnumProperties = new()
    {
        ["TextAlignment"] = "TMPro.TextAlignmentOptions",
        ["FontStyle"] = "TMPro.FontStyles",
        ["TextOverflow"] = "TMPro.TextOverflowModes",
        ["ContentType"] = "TMPro.TMP_InputField.ContentType",
        ["ImageType"] = "UnityEngine.UI.Image.Type",
        ["WrapMode"] = "TextureWrapMode",
        ["FilterMode"] = "FilterMode",
    };

    // Known color properties that need parsing
    private static readonly HashSet<string> ColorProperties = [
        "TextColor", "Background", "Color",
        "NormalColor", "HighlightedColor", "PressedColor", "SelectedColor", "DisabledColor",
        "ShadowColor"
    ];

    // Known margin/vector properties that need parsing
    private static readonly HashSet<string> MarginProperties = ["TextMargin"];

    // Known shadow distance properties that need special parsing
    private static readonly HashSet<string> ShadowDistanceProperties = ["ShadowDistance"];

    // Known pivot properties that need special parsing
    private static readonly HashSet<string> PivotProperties = ["Pivot"];

    private static string FormatPropertyValue(string propName, string value)
    {
        // Check if it's a known enum property
        if (EnumProperties.TryGetValue(propName, out var enumType))
        {
            return $"{enumType}.{value}";
        }

        // Check if it's a color property (hex string like #RGB, #RRGGBB, #RRGGBBAA)
        if (ColorProperties.Contains(propName) && value.StartsWith('#'))
        {
            return $"PanelControl.ParseColor(\"{value}\")";
        }

        // Check if it's a margin/vector property
        if (MarginProperties.Contains(propName))
        {
            return $"LabelStyleHelper.ParseMargin(\"{value}\")";
        }

        // Check if it's a shadow distance property
        if (ShadowDistanceProperties.Contains(propName))
        {
            return $"ShadowHelper.ParseDistance(\"{value}\")";
        }

        // Check if it's a pivot property
        if (PivotProperties.Contains(propName))
        {
            return $"ImageLoadingHelper.ParsePivot(\"{value}\")";
        }

        // Try to parse as bool
        if (bool.TryParse(value, out var boolValue))
            return boolValue.ToString().ToLowerInvariant();

        // Try to parse as number
        if (int.TryParse(value, out var intValue))
            return intValue.ToString();

        if (float.TryParse(value, out var floatValue))
            return $"{floatValue}f";

        // String value
        return $"\"{EscapeString(value)}\"";
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    private void AppendLine(string? line = null)
    {
        if (string.IsNullOrEmpty(line))
        {
            _sb.AppendLine();
            return;
        }

        _sb.Append(new string(' ', _indent * 4));
        _sb.AppendLine(line);
    }
}
