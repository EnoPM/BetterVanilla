using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using BetterVanilla.Options.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace BetterVanilla.Options.SourceGenerator;

public sealed class OptionsCodeGenerator
{
    public string Generate(OptionsDefinition definition)
    {
        var compilationUnit = CompilationUnit()
            .WithUsings(CreateUsings())
            .WithMembers(CreateNamespaceOrClass(definition))
            .WithLeadingTrivia(CreateHeaderTrivia())
            .NormalizeWhitespace();

        return compilationUnit.ToFullString();
    }

    private static SyntaxTriviaList CreateHeaderTrivia()
    {
        return TriviaList(
            Comment("// <auto-generated/>"),
            CarriageReturnLineFeed,
            Comment("// This file was generated by BetterVanilla.Options.Core.SourceGenerator."),
            CarriageReturnLineFeed,
            Comment("// Do not modify this file manually."),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed,
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
            CarriageReturnLineFeed
        );
    }

    private static SyntaxList<UsingDirectiveSyntax> CreateUsings()
    {
        var usings = new[]
        {
            "System.Collections.Generic",
            "BetterVanilla.Options.Core",
            "BetterVanilla.Options.Core.OptionTypes",
            "UnityEngine"
        };

        return List(usings.Select(u => UsingDirective(ParseName(u))));
    }

    private SyntaxList<MemberDeclarationSyntax> CreateNamespaceOrClass(OptionsDefinition definition)
    {
        var classDeclaration = CreateClassDeclaration(definition);

        if (!string.IsNullOrEmpty(definition.Namespace))
        {
            var namespaceDeclaration = FileScopedNamespaceDeclaration(ParseName(definition.Namespace!))
                .WithMembers(SingletonList<MemberDeclarationSyntax>(classDeclaration));

            return SingletonList<MemberDeclarationSyntax>(namespaceDeclaration);
        }

        return SingletonList<MemberDeclarationSyntax>(classDeclaration);
    }

    private ClassDeclarationSyntax CreateClassDeclaration(OptionsDefinition definition)
    {
        var members = new List<MemberDeclarationSyntax>();

        // Add option properties
        foreach (var option in definition.Options)
        {
            members.Add(CreateOptionProperty(option));
        }

        // Add GetAllOptions method
        members.Add(CreateGetAllOptionsMethod(definition.Options));

        return ClassDeclaration(definition.TypeName)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.PartialKeyword)))
            .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                SimpleBaseType(IdentifierName("OptionsHolderBase")))))
            .WithMembers(List(members));
    }

    private static PropertyDeclarationSyntax CreateOptionProperty(OptionEntry option)
    {
        var typeName = GetTypeName(option);
        var initializer = CreateOptionInitializer(option);

        return PropertyDeclaration(ParseTypeName(typeName), option.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithInitializer(EqualsValueClause(initializer))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static string GetTypeName(OptionEntry option)
    {
        // Use fully qualified names to avoid conflicts with game types (e.g., StringOption from Among Us)
        const string ns = "BetterVanilla.Options.Core.OptionTypes";
        return option.Type switch
        {
            OptionEntryType.Bool => $"{ns}.BoolOption",
            OptionEntryType.Int => $"{ns}.IntOption",
            OptionEntryType.Float => $"{ns}.FloatOption",
            OptionEntryType.String => $"{ns}.StringOption",
            OptionEntryType.Enum => $"{ns}.EnumOption<{option.EnumType}>",
            OptionEntryType.Color => $"{ns}.ColorOption",
            OptionEntryType.Vector2 => $"{ns}.Vector2Option",
            _ => "BetterVanilla.Options.Core.OptionBase"
        };
    }

    private static ExpressionSyntax CreateOptionInitializer(OptionEntry option)
    {
        var arguments = new List<ArgumentSyntax>
        {
            // Key argument
            Argument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(option.Name)))
        };

        switch (option.Type)
        {
            case OptionEntryType.Bool:
                arguments.Add(Argument(CreateBoolLiteral(option.Default)));
                break;

            case OptionEntryType.Int:
                arguments.Add(Argument(CreateIntLiteral(option.Default)));
                if (!string.IsNullOrEmpty(option.Min))
                    arguments.Add(Argument(CreateIntLiteral(option.Min)));
                else if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));
                if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(CreateIntLiteral(option.Max)));
                break;

            case OptionEntryType.Float:
                arguments.Add(Argument(CreateFloatLiteral(option.Default)));
                if (!string.IsNullOrEmpty(option.Min))
                    arguments.Add(Argument(CreateFloatLiteral(option.Min)));
                else if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));
                if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(CreateFloatLiteral(option.Max)));
                break;

            case OptionEntryType.String:
                arguments.Add(Argument(CreateStringLiteral(option.Default ?? "")));
                if (option.MaxLength.HasValue)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(option.MaxLength.Value))));
                break;

            case OptionEntryType.Enum:
                arguments.Add(Argument(CreateEnumValue(option.EnumType!, option.Default)));
                break;

            case OptionEntryType.Color:
                arguments.Add(Argument(CreateColorValue(option.Default)));
                break;

            case OptionEntryType.Vector2:
                arguments.Add(Argument(CreateVector2Value(option.Default)));
                break;
        }

        return ObjectCreationExpression(ParseTypeName(GetTypeName(option)))
            .WithArgumentList(ArgumentList(SeparatedList(arguments)));
    }

    private static LiteralExpressionSyntax CreateBoolLiteral(string? value)
    {
        var boolValue = !string.IsNullOrEmpty(value) && bool.TryParse(value, out var b) && b;
        return boolValue
            ? LiteralExpression(SyntaxKind.TrueLiteralExpression)
            : LiteralExpression(SyntaxKind.FalseLiteralExpression);
    }

    private static LiteralExpressionSyntax CreateIntLiteral(string? value)
    {
        var intValue = !string.IsNullOrEmpty(value) && int.TryParse(value, out var i) ? i : 0;
        return LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(intValue));
    }

    private static LiteralExpressionSyntax CreateFloatLiteral(string? value)
    {
        var floatValue = !string.IsNullOrEmpty(value) && float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var f) ? f : 0f;
        return LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(floatValue));
    }

    private static LiteralExpressionSyntax CreateStringLiteral(string value)
    {
        return LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value));
    }

    private static ExpressionSyntax CreateEnumValue(string enumType, string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return DefaultExpression(ParseTypeName(enumType));
        }

        return MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            IdentifierName(enumType),
            IdentifierName(value!));
    }

    private static ExpressionSyntax CreateColorValue(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("Color"),
                IdentifierName("white"));
        }

        // Parse hex color
        return InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("ColorOption"),
                    IdentifierName("ParseColor")))
            .WithArgumentList(ArgumentList(SingletonSeparatedList(
                Argument(CreateStringLiteral(value!)))));
    }

    private static ExpressionSyntax CreateVector2Value(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("Vector2"),
                IdentifierName("zero"));
        }

        // Parse "x,y" format
        return InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("Vector2Option"),
                    IdentifierName("ParseVector2")))
            .WithArgumentList(ArgumentList(SingletonSeparatedList(
                Argument(CreateStringLiteral(value!)))));
    }

    private static MethodDeclarationSyntax CreateGetAllOptionsMethod(List<OptionEntry> options)
    {
        var statements = new List<StatementSyntax>();

        foreach (var option in options)
        {
            statements.Add(YieldStatement(
                SyntaxKind.YieldReturnStatement,
                IdentifierName(option.Name)));
        }

        return MethodDeclaration(
                GenericName("IEnumerable")
                    .WithTypeArgumentList(TypeArgumentList(SingletonSeparatedList<TypeSyntax>(
                        IdentifierName("OptionBase")))),
                "GetAllOptions")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword)))
            .WithBody(Block(statements));
    }
}
