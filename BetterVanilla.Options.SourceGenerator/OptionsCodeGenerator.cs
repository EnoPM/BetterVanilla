using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using BetterVanilla.Options.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace BetterVanilla.Options.SourceGenerator;

public sealed class OptionsCodeGenerator
{
    public string Generate(OptionsDefinition definition)
    {
        var compilationUnit = CompilationUnit()
            .WithUsings(CreateUsings(definition))
            .WithMembers(CreateNamespaceOrClass(definition))
            .WithLeadingTrivia(CreateHeaderTrivia())
            .NormalizeWhitespace();

        return compilationUnit.ToFullString();
    }

    private static SyntaxTriviaList CreateHeaderTrivia()
    {
        return TriviaList(
            Comment("// <auto-generated/>"),
            CarriageReturnLineFeed,
            Comment("// This file was generated by BetterVanilla.Options.Core.SourceGenerator."),
            CarriageReturnLineFeed,
            Comment("// Do not modify this file manually."),
            CarriageReturnLineFeed,
            CarriageReturnLineFeed,
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
            CarriageReturnLineFeed
        );
    }

    private static SyntaxList<UsingDirectiveSyntax> CreateUsings(OptionsDefinition definition)
    {
        var usingsList = new List<string>
        {
            "System",
            "System.Collections.Generic",
            "BetterVanilla.Options.Core",
            "BetterVanilla.Options.Core.OptionTypes",
            "BetterVanilla.Localization",
            "UnityEngine"
        };

        return List(usingsList.Select(u => UsingDirective(ParseName(u))));
    }

    private SyntaxList<MemberDeclarationSyntax> CreateNamespaceOrClass(OptionsDefinition definition)
    {
        var classDeclaration = CreateClassDeclaration(definition);

        if (!string.IsNullOrEmpty(definition.Namespace))
        {
            var namespaceDeclaration = FileScopedNamespaceDeclaration(ParseName(definition.Namespace!))
                .WithMembers(SingletonList<MemberDeclarationSyntax>(classDeclaration));

            return SingletonList<MemberDeclarationSyntax>(namespaceDeclaration);
        }

        return SingletonList<MemberDeclarationSyntax>(classDeclaration);
    }

    private ClassDeclarationSyntax CreateClassDeclaration(OptionsDefinition definition)
    {
        var members = new List<MemberDeclarationSyntax>();

        // Add option properties
        foreach (var option in definition.Options)
        {
            members.Add(CreateOptionProperty(option, definition.DefaultLanguage));
        }

        // Add GetAllOptions method
        members.Add(CreateGetAllOptionsMethod(definition.Options));

        return ClassDeclaration(definition.TypeName)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.PartialKeyword)))
            .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(
                SimpleBaseType(IdentifierName("OptionsHolderBase")))))
            .WithMembers(List(members));
    }

    private static PropertyDeclarationSyntax CreateOptionProperty(OptionEntry option, string defaultLanguage)
    {
        var typeName = GetTypeName(option);
        var initializer = CreateOptionInitializer(option, defaultLanguage);

        return PropertyDeclaration(ParseTypeName(typeName), option.Name)
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithAccessorList(AccessorList(SingletonList(
                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)))))
            .WithInitializer(EqualsValueClause(initializer))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static string GetTypeName(OptionEntry option)
    {
        // Use fully qualified names to avoid conflicts with game types (e.g., StringOption from Among Us)
        const string ns = "BetterVanilla.Options.Core.OptionTypes";
        return option.Type switch
        {
            OptionEntryType.Bool => $"{ns}.BoolOption",
            OptionEntryType.Int => $"{ns}.IntOption",
            OptionEntryType.Float => $"{ns}.FloatOption",
            OptionEntryType.String => $"{ns}.StringOption",
            OptionEntryType.Enum => $"{ns}.EnumOption",
            OptionEntryType.Color => $"{ns}.ColorOption",
            OptionEntryType.Vector2 => $"{ns}.Vector2Option",
            _ => "BetterVanilla.Options.Core.OptionBase"
        };
    }

    private static ExpressionSyntax CreateOptionInitializer(OptionEntry option, string defaultLanguage)
    {
        var arguments = new List<ArgumentSyntax>
        {
            // Key argument
            Argument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(option.Name))),
            // Label provider lambda
            Argument(CreateTranslationLambda(option.LabelTranslations, defaultLanguage)),
            // Description provider lambda
            Argument(CreateTranslationLambda(option.DescriptionTranslations, defaultLanguage))
        };

        switch (option.Type)
        {
            case OptionEntryType.Bool:
                arguments.Add(Argument(CreateBoolLiteral(option.Default)));
                break;

            case OptionEntryType.Int:
                arguments.Add(Argument(CreateIntLiteral(option.Default)));
                if (!string.IsNullOrEmpty(option.Min))
                    arguments.Add(Argument(CreateIntLiteral(option.Min)));
                else if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));
                if (!string.IsNullOrEmpty(option.Max))
                    arguments.Add(Argument(CreateIntLiteral(option.Max)));
                break;

            case OptionEntryType.Float:
                arguments.Add(Argument(CreateFloatLiteral(option.Default)));
                // Handle min, max, step, prefix, suffix - need to pass nulls for missing intermediate values
                var hasMin = !string.IsNullOrEmpty(option.Min);
                var hasMax = !string.IsNullOrEmpty(option.Max);
                var hasStep = !string.IsNullOrEmpty(option.Step);
                var hasPrefix = !string.IsNullOrEmpty(option.Prefix);
                var hasSuffix = !string.IsNullOrEmpty(option.Suffix);

                if (hasMin)
                    arguments.Add(Argument(CreateFloatLiteral(option.Min)));
                else if (hasMax || hasStep || hasPrefix || hasSuffix)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));

                if (hasMax)
                    arguments.Add(Argument(CreateFloatLiteral(option.Max)));
                else if (hasStep || hasPrefix || hasSuffix)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));

                if (hasStep)
                    arguments.Add(Argument(CreateFloatLiteral(option.Step)));
                else if (hasPrefix || hasSuffix)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));

                if (hasPrefix)
                    arguments.Add(Argument(CreateStringLiteral(option.Prefix!)));
                else if (hasSuffix)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NullLiteralExpression)));

                if (hasSuffix)
                    arguments.Add(Argument(CreateStringLiteral(option.Suffix!)));
                break;

            case OptionEntryType.String:
                arguments.Add(Argument(CreateStringLiteral(option.Default ?? "")));
                if (option.MaxLength.HasValue)
                    arguments.Add(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(option.MaxLength.Value))));
                break;

            case OptionEntryType.Enum:
                // Create array of EnumChoice: new[] { new EnumChoice("value", () => "label"), ... }
                arguments.Add(Argument(CreateEnumChoicesArray(option.EnumChoices, defaultLanguage)));
                // Default value as string
                arguments.Add(Argument(CreateStringLiteral(option.Default ?? option.EnumChoices.FirstOrDefault()?.Value ?? "")));
                break;

            case OptionEntryType.Color:
                arguments.Add(Argument(CreateColorValue(option.Default)));
                break;

            case OptionEntryType.Vector2:
                arguments.Add(Argument(CreateVector2Value(option.Default)));
                break;
        }

        return ObjectCreationExpression(ParseTypeName(GetTypeName(option)))
            .WithArgumentList(ArgumentList(SeparatedList(arguments)));
    }

    private static ExpressionSyntax CreateTranslationLambda(Dictionary<string, string> translations, string defaultLanguage)
    {
        // Generate: () => LocalizationManager.CurrentLanguage switch { Language.Fr => "...", _ => "..." }
        // Or if no translations: () => ""

        if (translations.Count == 0)
        {
            // Return: () => ""
            return ParenthesizedLambdaExpression()
                .WithParameterList(ParameterList())
                .WithExpressionBody(CreateStringLiteral(string.Empty));
        }

        // Get the default translation
        string defaultTranslation;
        if (translations.TryGetValue(defaultLanguage, out var defValue))
        {
            defaultTranslation = defValue;
        }
        else
        {
            defaultTranslation = translations.Values.FirstOrDefault() ?? string.Empty;
        }

        // If only one language (the default), just return a simple lambda
        if (translations.Count == 1)
        {
            return ParenthesizedLambdaExpression()
                .WithParameterList(ParameterList())
                .WithExpressionBody(CreateStringLiteral(defaultTranslation));
        }

        // Build switch expression arms
        var switchArms = new List<SwitchExpressionArmSyntax>();

        // Use fully qualified name for Language enum to avoid conflicts with properties named "Language"
        var languageEnumType = ParseName("BetterVanilla.Localization.Language");

        foreach (var kvp in translations.OrderBy(x => x.Key))
        {
            var lang = kvp.Key;
            var text = kvp.Value;
            if (lang == defaultLanguage) continue;

            var arm = SwitchExpressionArm(
                ConstantPattern(
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        languageEnumType,
                        IdentifierName(lang))),
                CreateStringLiteral(text));

            switchArms.Add(arm);
        }

        // Add default arm (discard pattern)
        var defaultArm = SwitchExpressionArm(
            DiscardPattern(),
            CreateStringLiteral(defaultTranslation));
        switchArms.Add(defaultArm);

        // Create the switch expression with fully qualified LocalizationManager
        var switchExpression = SwitchExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                ParseName("BetterVanilla.Localization.LocalizationManager"),
                IdentifierName("CurrentLanguage")),
            SeparatedList(switchArms));

        // Return: () => switch expression
        return ParenthesizedLambdaExpression()
            .WithParameterList(ParameterList())
            .WithExpressionBody(switchExpression);
    }

    private static LiteralExpressionSyntax CreateBoolLiteral(string? value)
    {
        var boolValue = !string.IsNullOrEmpty(value) && bool.TryParse(value, out var b) && b;
        return boolValue
            ? LiteralExpression(SyntaxKind.TrueLiteralExpression)
            : LiteralExpression(SyntaxKind.FalseLiteralExpression);
    }

    private static LiteralExpressionSyntax CreateIntLiteral(string? value)
    {
        var intValue = !string.IsNullOrEmpty(value) && int.TryParse(value, out var i) ? i : 0;
        return LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(intValue));
    }

    private static LiteralExpressionSyntax CreateFloatLiteral(string? value)
    {
        var floatValue = !string.IsNullOrEmpty(value) && float.TryParse(value, NumberStyles.Float, CultureInfo.InvariantCulture, out var f) ? f : 0f;
        return LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(floatValue));
    }

    private static LiteralExpressionSyntax CreateStringLiteral(string value)
    {
        return LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value));
    }

    private static ExpressionSyntax CreateEnumChoicesArray(List<EnumChoiceEntry> choices, string defaultLanguage)
    {
        // Generate: new[] { new EnumChoice("Value1", () => "Label1"), new EnumChoice("Value2", () => "Label2") }
        var choiceExpressions = new List<ExpressionSyntax>();

        foreach (var choice in choices)
        {
            // new EnumChoice("value", () => label)
            var choiceCreation = ObjectCreationExpression(
                    ParseTypeName("BetterVanilla.Options.Core.OptionTypes.EnumChoice"))
                .WithArgumentList(ArgumentList(SeparatedList(new[]
                {
                    Argument(CreateStringLiteral(choice.Value)),
                    Argument(CreateTranslationLambda(choice.LabelTranslations, defaultLanguage))
                })));

            choiceExpressions.Add(choiceCreation);
        }

        // new[] { ... }
        return ImplicitArrayCreationExpression(
            InitializerExpression(
                SyntaxKind.ArrayInitializerExpression,
                SeparatedList(choiceExpressions)));
    }

    private static ExpressionSyntax CreateColorValue(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("Color"),
                IdentifierName("white"));
        }

        // Parse hex color
        return InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("ColorOption"),
                    IdentifierName("ParseColor")))
            .WithArgumentList(ArgumentList(SingletonSeparatedList(
                Argument(CreateStringLiteral(value!)))));
    }

    private static ExpressionSyntax CreateVector2Value(string? value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("Vector2"),
                IdentifierName("zero"));
        }

        // Parse "x,y" format
        return InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("Vector2Option"),
                    IdentifierName("ParseVector2")))
            .WithArgumentList(ArgumentList(SingletonSeparatedList(
                Argument(CreateStringLiteral(value!)))));
    }

    private static MethodDeclarationSyntax CreateGetAllOptionsMethod(List<OptionEntry> options)
    {
        var statements = new List<StatementSyntax>();

        foreach (var option in options)
        {
            statements.Add(YieldStatement(
                SyntaxKind.YieldReturnStatement,
                IdentifierName(option.Name)));
        }

        return MethodDeclaration(
                GenericName("IEnumerable")
                    .WithTypeArgumentList(TypeArgumentList(SingletonSeparatedList<TypeSyntax>(
                        IdentifierName("OptionBase")))),
                "GetAllOptions")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.OverrideKeyword)))
            .WithBody(Block(statements));
    }
}
