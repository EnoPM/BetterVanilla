using System.Collections.Generic;
using System.Linq;
using System.Text;
using BetterVanilla.Localization.SourceGenerator.Models;

namespace BetterVanilla.Localization.SourceGenerator;

public sealed class LocalizationCodeGenerator
{
    public string Generate(LocalizationDefinition definition)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This file was generated by BetterVanilla.Localization.SourceGenerator.");
        sb.AppendLine("// Do not modify this file manually.");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using BetterVanilla.Localization;");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(definition.Namespace))
        {
            sb.AppendLine($"namespace {definition.Namespace};");
            sb.AppendLine();
        }

        // Static class (no more enum generation)
        GenerateStaticClass(sb, definition);

        return sb.ToString();
    }

    private static void GenerateStaticClass(StringBuilder sb, LocalizationDefinition definition)
    {
        const string enumName = "Language";
        var defaultLang = definition.DefaultLanguage;

        sb.AppendLine($"public static partial class {definition.TypeName}");
        sb.AppendLine("{");

        // SupportedLanguages property
        sb.AppendLine($"    public static {enumName}[] SupportedLanguages {{ get; }} = new[]");
        sb.AppendLine("    {");
        for (var i = 0; i < definition.Languages.Count; i++)
        {
            var lang = definition.Languages[i];
            var comma = i < definition.Languages.Count - 1 ? "," : "";
            sb.AppendLine($"        {enumName}.{lang}{comma}");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Keys property
        sb.AppendLine("    public static string[] Keys { get; } = new[]");
        sb.AppendLine("    {");
        for (var i = 0; i < definition.Entries.Count; i++)
        {
            var entry = definition.Entries[i];
            var comma = i < definition.Entries.Count - 1 ? "," : "";
            sb.AppendLine($"        \"{entry.Key}\"{comma}");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Get method
        sb.AppendLine("    public static string Get(string key) => key switch");
        sb.AppendLine("    {");
        foreach (var entry in definition.Entries)
        {
            sb.AppendLine($"        \"{entry.Key}\" => {entry.Key},");
        }
        sb.AppendLine("        _ => $\"[{key}]\"");
        sb.AppendLine("    };");
        sb.AppendLine();

        // Translation properties
        foreach (var entry in definition.Entries)
        {
            GenerateTranslationProperty(sb, entry, definition, enumName);
        }

        sb.AppendLine("}");
    }

    private static void GenerateTranslationProperty(
        StringBuilder sb,
        TranslationEntry entry,
        LocalizationDefinition definition,
        string enumName)
    {
        sb.AppendLine($"    public static string {entry.Key} => LocalizationManager.CurrentLanguage switch");
        sb.AppendLine("    {");

        // Generate cases for each language (except default)
        foreach (var lang in definition.Languages)
        {
            if (lang == definition.DefaultLanguage) continue;

            if (entry.Translations.TryGetValue(lang, out var translation))
            {
                sb.AppendLine($"        {enumName}.{lang} => {EscapeString(translation)},");
            }
        }

        // Default case (default language)
        var defaultTranslation = entry.Translations.TryGetValue(definition.DefaultLanguage, out var defaultTrans)
            ? defaultTrans
            : entry.Translations.Values.FirstOrDefault() ?? entry.Key;

        sb.AppendLine($"        _ => {EscapeString(defaultTranslation)}");
        sb.AppendLine("    };");
        sb.AppendLine();
    }

    private static string EscapeString(string value)
    {
        // Use verbatim string if it contains special characters
        if (value.Contains('\n') || value.Contains('\r') || value.Contains('\t'))
        {
            // Use raw string literal for multiline
            var escaped = value
                .Replace("\"", "\"\"");
            return $"@\"{escaped}\"";
        }

        // Regular string escaping
        var result = value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{result}\"";
    }
}
