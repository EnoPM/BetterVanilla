using System.Text;
using BetterVanilla.Ui.XamlGenerator.Models;

namespace BetterVanilla.Ui.XamlGenerator;

/// <summary>
/// Generates C# code from parsed ViewDefinition.
/// </summary>
public sealed class CodeGenerator
{
    private readonly AliasConfig _aliasConfig;
    private readonly StringBuilder _sb = new();
    private int _indent;

    public CodeGenerator(AliasConfig aliasConfig)
    {
        _aliasConfig = aliasConfig;
    }

    public string Generate(ViewDefinition definition)
    {
        _sb.Clear();
        _indent = 0;

        // Header
        AppendLine("// <auto-generated/>");
        AppendLine("// This file was generated by BetterVanilla.Ui.XamlGenerator.");
        AppendLine("// Do not modify this file manually.");
        AppendLine();
        AppendLine("#nullable enable");
        AppendLine();

        // Usings
        AppendLine("using System;");
        AppendLine("using System.Collections.Generic;");
        AppendLine("using BetterVanilla.Ui.Binding;");
        AppendLine("using BetterVanilla.Ui.Controls;");
        AppendLine("using BetterVanilla.Ui.Core;");
        AppendLine("using BetterVanilla.Ui.Helpers;");
        AppendLine("using UnityEngine;");
        AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(definition.Namespace))
        {
            AppendLine($"namespace {definition.Namespace};");
            AppendLine();
        }

        // Class (no base class - user code specifies it)
        AppendLine($"public partial class {definition.TypeName}");
        AppendLine("{");
        _indent++;

        GenerateFields(definition);
        AppendLine();
        GenerateAliasMap(definition);
        AppendLine();
        GenerateInitializeComponent(definition);
        AppendLine();
        GenerateSetupBindings(definition);
        AppendLine();
        GenerateSetupEventHandlers(definition);
        AppendLine();
        GeneratePartialMethods(definition);

        _indent--;
        AppendLine("}");

        return _sb.ToString();
    }

    private void GenerateFields(ViewDefinition definition)
    {
        AppendLine("#region View Elements");
        AppendLine();

        foreach (var element in definition.NamedElements)
        {
            var componentType = ResolveComponentType(element);
            AppendLine($"[ViewElement(\"{element.Name}\")]");
            AppendLine($"public {componentType} {element.Name} {{ get; private set; }} = null!;");
            AppendLine();
        }

        AppendLine("#endregion");
    }

    private void GenerateAliasMap(ViewDefinition definition)
    {
        AppendLine("#region Alias Mappings");
        AppendLine();
        AppendLine("private static readonly Dictionary<string, (string Bundle, string Prefab, Type Component)> AliasMap = new()");
        AppendLine("{");
        _indent++;

        var processedAliases = new HashSet<string>();

        foreach (var element in definition.NamedElements)
        {
            var alias = element.Alias ?? element.TagName;
            if (processedAliases.Contains(alias))
                continue;

            processedAliases.Add(alias);

            if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
            {
                var bundle = aliasDef.Bundle ?? _aliasConfig.DefaultBundle ?? "ui.bundle";
                AppendLine($"[\"{alias}\"] = (\"{bundle}\", \"{aliasDef.Prefab}\", typeof({aliasDef.Component})),");
            }
        }

        _indent--;
        AppendLine("};");
        AppendLine();
        AppendLine("#endregion");
    }

    private void GenerateInitializeComponent(ViewDefinition definition)
    {
        AppendLine("protected override void InitializeComponent()");
        AppendLine("{");
        _indent++;

        AppendLine("// Load and instantiate elements");

        if (definition.RootElement != null)
        {
            GenerateElementInstantiation(definition.RootElement, "transform", isRoot: true);
        }

        AppendLine();
        AppendLine("// Register elements");
        foreach (var element in definition.NamedElements)
        {
            AppendLine($"RegisterElement(\"{element.Name}\", {element.Name});");
        }

        AppendLine();
        AppendLine("base.InitializeComponent();");

        _indent--;
        AppendLine("}");
    }

    private void GenerateElementInstantiation(ViewElement element, string parentVar, bool isRoot = false)
    {
        if (string.IsNullOrEmpty(element.Name))
        {
            // Anonymous element - still need to process children
            foreach (var child in element.Children)
            {
                GenerateElementInstantiation(child, parentVar);
            }
            return;
        }

        var alias = element.Alias ?? element.TagName;
        var componentType = ResolveComponentType(element);

        AppendLine();
        AppendLine($"// Instantiate {element.Name}");

        if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
        {
            var bundle = aliasDef.Bundle ?? _aliasConfig.DefaultBundle ?? "ui.bundle";
            AppendLine($"{element.Name} = InstantiateControl<{componentType}>(\"{bundle}\", \"{aliasDef.Prefab}\", {parentVar});");
        }
        else
        {
            // Fallback - create empty GameObject with component
            AppendLine($"var {element.Name}Go = new GameObject(\"{element.Name}\");");
            AppendLine($"{element.Name}Go.transform.SetParent({parentVar}, false);");
            AppendLine($"{element.Name} = {element.Name}Go.AddComponent<{componentType}>();");
        }

        AppendLine($"{element.Name}.Name = \"{element.Name}\";");
        AppendLine($"{element.Name}.Initialize();");

        // Set literal properties
        foreach (var (propName, propValue) in element.LiteralProperties)
        {
            var formattedValue = FormatPropertyValue(propValue);
            AppendLine($"{element.Name}.{propName} = {formattedValue};");
        }

        // Process children
        foreach (var child in element.Children)
        {
            GenerateElementInstantiation(child, $"{element.Name}.transform");
        }
    }

    private void GenerateSetupBindings(ViewDefinition definition)
    {
        AppendLine("protected override void SetupBindings()");
        AppendLine("{");
        _indent++;

        var hasBindings = false;

        foreach (var element in definition.NamedElements)
        {
            foreach (var (propName, binding) in element.Bindings)
            {
                hasBindings = true;
                AppendLine($"Bind(\"{binding.Path}\", {element.Name}, \"{propName}\", BindingMode.{binding.Mode}).AddTo(Disposables);");
            }
        }

        if (!hasBindings)
        {
            AppendLine("// No bindings defined");
        }

        _indent--;
        AppendLine("}");
    }

    private void GenerateSetupEventHandlers(ViewDefinition definition)
    {
        AppendLine("protected override void SetupEventHandlers()");
        AppendLine("{");
        _indent++;

        var hasEvents = false;

        foreach (var element in definition.NamedElements)
        {
            foreach (var (eventName, handlerName) in element.EventHandlers)
            {
                hasEvents = true;
                var componentType = ResolveComponentType(element);
                var valueType = GetValueTypeForComponent(componentType);

                // Handle common events
                switch (eventName)
                {
                    case "Click" or "Clicked":
                        AppendLine($"if ({element.Name} is IClickableControl clickable{element.Name})");
                        AppendLine("{");
                        _indent++;
                        AppendLine($"clickable{element.Name}.Clicked += {handlerName};");
                        _indent--;
                        AppendLine("}");
                        break;

                    case "ValueChanged":
                        if (valueType != null)
                        {
                            // We know the specific value type for this control
                            AppendLine($"{element.Name}.ValueChanged += value => {handlerName}(value);");
                        }
                        else
                        {
                            // Unknown control type - use dynamic check (but this should be rare)
                            AppendLine($"// Unknown control type: {componentType}");
                        }
                        break;

                    default:
                        AppendLine($"// TODO: Wire up {eventName} to {handlerName}");
                        break;
                }
            }
        }

        if (!hasEvents)
        {
            AppendLine("// No event handlers defined");
        }

        _indent--;
        AppendLine("}");
    }

    /// <summary>
    /// Gets the value type for a known control component type.
    /// </summary>
    private static string? GetValueTypeForComponent(string componentType)
    {
        return componentType switch
        {
            "ToggleControl" => "bool",
            "SliderControl" => "float",
            "InputFieldControl" => "string",
            _ => null
        };
    }

    private void GeneratePartialMethods(ViewDefinition definition)
    {
        AppendLine("#region Partial Methods (implement in user code)");
        AppendLine();

        // Collect methods with their expected parameter types
        var methodSignatures = new Dictionary<string, HashSet<string?>>();

        foreach (var element in definition.NamedElements)
        {
            var componentType = ResolveComponentType(element);

            foreach (var (eventName, handlerName) in element.EventHandlers)
            {
                if (!methodSignatures.TryGetValue(handlerName, out var paramTypes))
                {
                    paramTypes = new HashSet<string?>();
                    methodSignatures[handlerName] = paramTypes;
                }

                if (eventName is "Click" or "Clicked")
                {
                    paramTypes.Add(null); // No parameter
                }
                else if (eventName == "ValueChanged")
                {
                    var valueType = GetValueTypeForComponent(componentType);
                    if (valueType != null)
                    {
                        paramTypes.Add(valueType);
                    }
                }
            }
        }

        foreach (var (method, paramTypes) in methodSignatures)
        {
            foreach (var paramType in paramTypes)
            {
                if (paramType == null)
                {
                    AppendLine($"partial void {method}();");
                }
                else
                {
                    AppendLine($"partial void {method}({paramType} value);");
                }
            }
        }

        AppendLine();
        AppendLine("#endregion");
    }

    private string ResolveComponentType(ViewElement element)
    {
        var alias = element.Alias ?? element.TagName;

        if (_aliasConfig.Aliases.TryGetValue(alias, out var aliasDef))
        {
            // Return just the type name, not the full namespace
            var lastDot = aliasDef.Component.LastIndexOf('.');
            return lastDot > 0 ? aliasDef.Component[(lastDot + 1)..] : aliasDef.Component;
        }

        // Default to tag name + Control suffix
        return element.TagName.EndsWith("Control") ? element.TagName : $"{element.TagName}Control";
    }

    private static string FormatPropertyValue(string value)
    {
        // Try to parse as bool
        if (bool.TryParse(value, out var boolValue))
            return boolValue.ToString().ToLowerInvariant();

        // Try to parse as number
        if (int.TryParse(value, out var intValue))
            return intValue.ToString();

        if (float.TryParse(value, out var floatValue))
            return $"{floatValue}f";

        // String value
        return $"\"{EscapeString(value)}\"";
    }

    private static string EscapeString(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }

    private void AppendLine(string? line = null)
    {
        if (string.IsNullOrEmpty(line))
        {
            _sb.AppendLine();
            return;
        }

        _sb.Append(new string(' ', _indent * 4));
        _sb.AppendLine(line);
    }
}
